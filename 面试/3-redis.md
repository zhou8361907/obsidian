# 为什么使用redis
性能
	执行耗时长且结果不频繁变动的数据，暂时放入缓存，节约时间
并发
	可以用redis做大并发的请求的缓冲操作，不直接访问数据库
分布式锁
# 用缓存的目的
高性能
	节约负责且不变的结果的查询时间
高并发
	缓存走的内存，天然支持高并发，可以缓解大并发量的请求直接访问数据库
缓存问题：与数据库读写不一致，缓存雪崩，缓存穿透，缓存并发竞争
# redis的数据类型
+ string
+ hash
+ list
+ set
+ sorted set
## hash
设置字段值：HSET key field value
获取字段值：HGET key field
获取所有字段和值：HGETALL key
删除字段：HDEL key field [field ...]
## list
左侧插入元素：LPUSH key value [value ...]
右侧插入元素：RPUSH key value [value ...]
左侧弹出元素：LPOP key
右侧弹出元素：RPOP key
获取列表范围内的元素：LRANGE key start stop

# redis的过期策略
定期删除
	redis默认每隔100ms就会随机抽取一些设置了过期时间的key进行删除
	为了防止redis存放的可以过大，直接轮询负载太大
惰性删除
	当查询到这个key的时候才去检测，如果过去则删除
	缺点是一只占用内存
这两种方式都会固定使用，但是结果肯定会导致大量过期key堆积
## 内存淘汰机制
+ volatile-lru（Least Recently Used，最近最少使用）：从所有设置了过期时间的键中，移除最近最少使用的键。如果没有键设置了过期时间，则不会移除任何键。
+ allkeys-lru：从所有键中，不仅仅是过期的键，移除最近最少使用的键。这是一种全局的LRU策略。
+ volatile-ttl：从所有设置了过期时间的键中，移除剩余生存时间（TTL）最小的键。如果多个键具有相同的最小TTL，则按照LRU原则选择。
+ allkeys-random：从所有键中随机选择键进行移除。这是一种随机淘汰策略。
+ volatile-random：仅从设置了过期时间的键中随机选择键进行移除。


# redis事务
不支持回滚
执行事务期间，不会被其他客户端命令打断，先执行完当前事务
不支持回滚可以保存简单、快速的特性

# redis如果大量key同时过期
会出现卡顿，严重会出现缓存雪崩，一般要在时间上加个随机值
# redis为什么快
## 完全基于内存操作
使用内存，可以避免频繁的写盘操作
## 高效的数据结构
### 跳表

## I/O多路复用
多路指的是多个socket网络连接
复用：复用一个线程
## 避免上下文切换
因为是单线程



# redis的IO处理线程模型
## 文件处理器
+ 多个socket
+ IO多路复用程序
+ 文件事件派发器
+ 时间处理器（连接应答处理器、命令请求处理器、命令回复处理器）
IO多路复用程序会坚挺多个socket，会讲产生时间的socket放入队列中排队，时间派发器每次从队列中取出一个socket，根据socket的时间类型交给对应的事件处理器

# 6.0后引入多线程
redis6.0直邮在网络请求的接收和解析，以及请求后的数据通过网络返回的时候，使用了多线程。
数据的读写操作还是多线程来完成

# redis分布式锁
使用setnx来争抢锁，然后使用expire来加个过期时间
如果在setnx之后执行expire之前进程意外，这个锁救永远得不到释放
```
String script = "if redis.call('setNx',KEYS[1],ARGV[1]) " +  
        "then if redis.call('get',KEYS[1])==ARGV[1] " +  
        "then return redis.call('expire',KEYS[1],ARGV[2]) " +  
        "else return 0 end end";
```
# 如果要在1亿个key中提取10w个key
可以使用keys指令，但是redis是单线程的，数据量过大会导致线上服务停顿
这时候可以使用scan指令，可以无阻塞的提取指定模式的key列表
# 使用redis做一步队列
使用list结构做队列，rpush生产消息，lpop消费消息

# redis主从复制核心流程
主从复制：将一台redis服务器的数据复制到其他redis服务器上
+ 主节点（master）从节点（slave）
+ 复制是单向的，只能主节点到从节点
+ 默认情况下，没太redis服务器都是主节点
+ 一个主节点可以包含多个从节点，但是一个从节点只能有一个主节点
作用
+ 数据冗余
+ 故障恢复
+ 负载均衡：读写分离，主节点提供写，从节点提供读
+ 高可用、高并发基石：
核心流程：
+ 连接建立：在从节点数据命令与主节点建立关系，主节点启动一个后台线程，生成RDB文件发送
+ 数据同步：
+ 命令传播

# 缓存击穿、缓存穿透、缓存雪崩
缓存穿透
	指的是大量查询无法在缓存中获取，每次都绕过缓存直接查询数据库
	解决方法：
	1.对控制缓存，过期时间设置短一点
	2.采用布隆过滤器
	3.设置访问名单，拦截恶意请求
	4.对命中率下降的数据进行实时监控
缓存击穿
	某个热点key，访问非常频繁，在这个key失效的瞬间，大量请求直接访问到了数据库，导致崩溃
	解决方法：
	1.预先设置热门数据的过期时间延长
	2.实时调整key的过期时间
	3.热点key的设置永不过期
	4.加锁更新，发现缓存key没有，对该key进行加锁，去数据库查询出来写入缓存，在返回用户
缓存雪崩
	某一刻发生大规模的缓存失效请款，导致大量请求被直接打到DB上，导致系统崩溃
	解决方法：
	集群部署redis
	多级缓存redis
	均匀过期时间
	热点数据永不过期
	熔断升级
	